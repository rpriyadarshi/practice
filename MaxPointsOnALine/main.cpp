#include <iostream>
#include <vector>
#include <set>
#include <map>
#include <numeric>

/*
[[1,1],[2,2],[3,3]]

[[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]

[[1,1],[3,2],[5,3],[4,1],[2,3],[1,4],[2,0],[6,2]]

[]

[[4,0],[4,-1],[4,5]]

[[1,1],[1,1],[1,1]]

[[1,1],[1,1],[1,1],[1,1],[1,1],[1,1]]

[[1,1],[3,2],[3,2],[5,3],[4,1],[4,1],[2,3],[1,4],[2,0],[6,2],[3,2],[4,1]]

[[0,0]]

[[0,0],[0,0]]

[[1,1],[1,1],[0,0],[3,4],[4,5],[5,6],[7,8],[8,9]]

[[15,12],[9,10],[-16,3],[-15,15],[11,-10],[-5,20],[-3,-15],[-11,-8],[-8,-3],[3,6],[15,-14],[-16,-18],[-6,-8],[14,9],[-1,-7],[-1,-2],[3,11],[6,20],[10,-7],[0,14],[19,-18],[-10,-15],[-17,-1],[8,7],[20,-18],[-4,-9],[-9,16],[10,14],[-14,-15],[-2,-10],[-18,9],[7,-5],[-12,11],[-17,-6],[5,-17],[-2,-20],[15,-2],[-5,-16],[1,-20],[19,-12],[-14,-1],[18,10],[1,-20],[-15,19],[-18,13],[13,-3],[-16,-17],[1,0],[20,-18],[7,19],[1,-6],[-7,-11],[7,1],[-15,12],[-1,7],[-3,-13],[-11,2],[-17,-5],[-12,-14],[15,-3],[15,-11],[7,3],[19,7],[-15,19],[10,-14],[-14,5],[0,-1],[-12,-4],[4,18],[7,-3],[-5,-3],[1,-11],[1,-1],[2,16],[6,-6],[-17,9],[14,3],[-13,8],[-9,14],[-5,-1],[-18,-17],[9,-10],[19,19],[16,7],[3,7],[-18,-12],[-11,12],[-15,20],[-3,4],[-18,1],[13,17],[-16,-15],[-9,-9],[15,8],[19,-9],[9,-17]]

 [[0,0],[94911151,94911150],[94911152,94911151]]

 [[0,9],[138,429],[115,359],[115,359],[-30,-102],[230,709],[-150,-686],[-135,-613],[-60,-248],[-161,-481],[207,639],[23,79],[-230,-691],[-115,-341],[92,289],[60,336],[-105,-467],[135,701],[-90,-394],[-184,-551],[150,774]]
 */

class Solution {
public: // Alias
    using Point = std::tuple<int, int>;
    using Usage = std::map<Point, int>;
    using Points = std::set<Point>;
    using Segments = std::map<Point, Points>;
    using Slope = std::pair<int, int>;
    using Slopes = std::map<Slope, Segments>;

public: // Data
    Usage _usage;
    Slopes _slopes;

public: // Helpers
    void print() const {
        for (auto& s : _slopes) {
            std::cout << "{" << s.first.first << ", " << s.first.second << "}" << std::endl;
            for (auto& segs : s.second) {
                std::cout << "    {" << std::get<0>(segs.first) << ", " << std::get<1>(segs.first) << "} -> ";
                for (auto& pt : segs.second) {
                    std::cout << "(" << std::get<0>(pt) << ", " << std::get<1>(pt) << ") ";
                }
                std::cout << std::endl;
            }
            std::cout << std::endl;
        }
    }

public:
    int maxPoints(std::vector<std::vector<int>>& points) {
        if (points.empty()) {
            return 0;
        } else if (points.size() == 1) {
            return 1;
        }

        for (int i = 0; i < points.size(); i++) {
            auto& p = points[i];
            _usage[Point(p[0], p[1])]++;
        }

        // Build slope groups
        for (int i = 0; i < points.size(); i++) {
            auto& p1 = points[i];
            int x1 = p1[0];
            int y1 = p1[1];
            Point pt1(x1, y1);

            for (int j = i + 1; j < points.size(); j++) {
                auto& p2 = points[j];
                int x2 = p2[0];
                int y2 = p2[1];
                Point pt2(x2, y2);

                int p = y2 - y1;
                int q = x2 - x1;
                if (q < 0) {
                    p = -p;
                    q = -q;
                }
                int g = std::gcd(p, q);
                if (g > 1) {
                    p /= g;
                    q /= g;
                }

                auto& segs = _slopes[Slope(p, q)];
                segs[pt1].emplace(pt1);
                segs[pt1].emplace(pt2);
                segs[pt2].emplace(pt1);
                segs[pt2].emplace(pt2);
            }
        }

//        print();

        // find the largest group
        size_t maxsize = std::numeric_limits<size_t>::min();
        for (auto& s : _slopes) {
            for (auto& segs : s.second) {
                // size_t segsize = segs.second.size();
                size_t segsize = 0;
                for (auto& pt : segs.second) {
                    segsize += _usage[pt];
                }
                maxsize = std::max(maxsize, segsize);
            }
        }
        return maxsize;
    }
};

void runtest(std::vector<std::vector<int>> points, int res) {
    Solution sol;
    int cnt = sol.maxPoints(points);
    if (cnt == res) {
        std::cout << "PASS [" << cnt << "==" << res << "]";
    } else {
        std::cout << "FAIL [" << cnt << "!=" << res << "]";
    }
    std::cout << std::endl;
}

int main() {
    runtest({{1,1},{2,2},{3,3}}, 3);
    runtest({{1,1},{3,2},{5,3},{4,1},{2,3},{1,4}}, 4);
    runtest({{1,1},{3,2},{5,3},{4,1},{2,3},{1,4},{2,0},{6,2}}, 4);
    runtest({}, 0);
    runtest({{4,0},{4,-1},{4,5}}, 3);
    runtest({{1,1},{1,1},{1,1}}, 3);
    runtest({{1,1},{1,1},{1,1},{1,1},{1,1},{1,1}}, 6);
    runtest({{1,1},{3,2},{3,2},{5,3},{4,1},{4,1},{2,3},{1,4},{2,0},{6,2},{3,2},{4,1}}, 8);
    runtest({{0,0}}, 1);
    runtest({{0,0},{0,0}}, 2);
    runtest({{1,1},{1,1},{0,0},{3,4},{4,5},{5,6},{7,8},{8,9}}, 5);
    runtest({{15,12},{9,10},{-16,3},{-15,15},{11,-10},{-5,20},{-3,-15},{-11,-8},{-8,-3},{3,6},{15,-14},{-16,-18},{-6,-8},{14,9},{-1,-7},{-1,-2},{3,11},{6,20},{10,-7},{0,14},{19,-18},{-10,-15},{-17,-1},{8,7},{20,-18},{-4,-9},{-9,16},{10,14},{-14,-15},{-2,-10},{-18,9},{7,-5},{-12,11},{-17,-6},{5,-17},{-2,-20},{15,-2},{-5,-16},{1,-20},{19,-12},{-14,-1},{18,10},{1,-20},{-15,19},{-18,13},{13,-3},{-16,-17},{1,0},{20,-18},{7,19},{1,-6},{-7,-11},{7,1},{-15,12},{-1,7},{-3,-13},{-11,2},{-17,-5},{-12,-14},{15,-3},{15,-11},{7,3},{19,7},{-15,19},{10,-14},{-14,5},{0,-1},{-12,-4},{4,18},{7,-3},{-5,-3},{1,-11},{1,-1},{2,16},{6,-6},{-17,9},{14,3},{-13,8},{-9,14},{-5,-1},{-18,-17},{9,-10},{19,19},{16,7},{3,7},{-18,-12},{-11,12},{-15,20},{-3,4},{-18,1},{13,17},{-16,-15},{-9,-9},{15,8},{19,-9},{9,-17}}, 6);
    runtest({{0,0},{94911151,94911150},{94911152,94911151}}, 2);
    runtest({{0,9},{138,429},{115,359},{115,359},{-30,-102},{230,709},{-150,-686},{-135,-613},{-60,-248},{-161,-481},{207,639},{23,79},{-230,-691},{-115,-341},{92,289},{60,336},{-105,-467},{135,701},{-90,-394},{-184,-551},{150,774}}, 12);
    return 0;
}
